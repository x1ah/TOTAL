# 面向对象编程(oop)

## 概念
- 类最终解释了面对对象的思想。但是 **类 ！= 面对对象** 
- 面对对象编程主要有8连个主题，分别是 类 和 类实例。
- 类和实例相互关联着，类是对象的定义，而实例时真正的实物。
- 类分为经典类和新式类，新式类就相当于从别的类继承而来的。而经典类就是没有从别的类继承，直接父类就是`object` object 是‘所有类之母’ 位于所有类继承结构的最上层。如果没有直接或间接的子类化一个对象，那么就定义了一个经典类。
- 如果没有直接某个实例保存到某个变量里面，那么这是没用的，**因为自动垃圾收集器回收。**,所以这么做事实上就是给这个实例分配了一块内存。然后我们可以释放他。

## 面对对象编程
- 组织起来以便重复或重用。
- `deitel` 父子。
- 面向对象设计(OOD)
- 面向对象设计不会要求某一特定的面对对象语言。
- Python中有关面向对象的一些专业术语。
> 抽象/实现。。  封装/接口。。 合成。。 派生/继承/继承结构。。 泛化/特化。。 多态。。 自省/反射

## 类
- 类是一种数据结构。可以用它了定义对象。累世显示世界的抽象的实体以编程形式出现。实例时这些对象的具体化。
- 在类中定义方法。
- 派生 ，类似于继承。
- 类的定义紧跟在声明（class）后面

## 类的属性
- 属性就是属于另一个对象的数据或者函数元素。同样的，可以通过句点属性标识法来访问。在访问某个属性的同时，这个属性也是一个对象。所以这个属性还有自己的属性。这样就导致了一个属性链。
- 实例对象使用的比较多。实例数据属性是会一直用到的主要数据属性。
- **静态** 表示一个值，不会因为函数调用完毕而消失。他在没两个函数调用的间隙都存在。或者说，一个类中的一些数据对所有的实例来说。都是固定的。
- **通常在Python中所有的方法都有一个限制，就是：在调用前，需要创建一个实例**
- 数据属性仅仅是所定义的类的变量。这些属性可以想其他任何变量一样在类创建以后被使用。并且，要么是由类中的方法来更新。要么是在主程序中的某个地方被更新。**这种属性就叫做 -- 静态变量 ，或者是静态数据**
- 他们表示这些数据和他们所属的类对象是绑定的。不依赖于任何类实例。
- 类属性--表示直接就是类对象的属性。而 实例属性--表示创建一个实例之后这个实例的属性。
- 类对象的属性是通过句点属性标识法来绑定的。
- 为了于OOP惯例保持一致，Python严格要求，没有实例，方法使不能被调用的。这种限制就是Python所描述的绑定概念（binding）所以，方法必须绑定到一个实例才能直接被调用。非绑定的方法可以被调用但是一定要指出实例对象。
- 查看类的属性可以有 `class.__dict__` 或者 `dir（class）` 前者不仅返回属性名字，还返回了对应属性的数据值。
- `__doc__` `__moudle__` 是所有类都具备的特殊属性。

| `c.__name__` | 类c的名字 |
|-----------| ------|
|`c.__doc__` | c的文档|
|`c.__bases__`| c的所有父类构成的元组|
|`c.__dict__`| c的属性|
|`c.__moduole__`| c定义所在的模块|
|`c.__class__`| 实例c对应的类|


- `__doc__`是类的文档字符串。文档必须紧跟头行。文档类的字符串不能被派生类继承。所以派生类就必须要有自己的文档字符串。
- 访问一个类属性的时候，Python解释器会搜索字典`__dict__`。如果在这个字典里面没有找到。那么就会在基类字典中搜索。采用的 ** 深度优先搜索 ** 顺序。
- 假如有一个类对象c。没有从任何类继承。那么这个类对象的全名叫做 `__main__.c`这也就解释了为何我们经常会用 `if __name__ == __main__`

## 实例
- 如果说类是一种数据结果定义类型。那么实例则声明了一个这种类型的变量。换一种说法，实例时有生命的类对象。
- 初始化。也就是创建一个实例。
- 当类被调用，实例化的第一步就是创建实例对象。一旦对象创建了。Python会检查 是否实现了`__init__()`方法。默认情况下。如果没有定义特殊方法init。对实例不会做任何特别的操作。
- 任何所需ide特定的操作，都需要实现`__init__()`方法。覆盖他的默认行为。
- `__init__()`构造器方法。如果这个实现了。那么他将被调用。实例对象作为第一个参数self被传递进去。想标准方法一样。调用类时，传进的任何参数都交给了`init` 可以 想象成：**把创建实例的调用当成时对构造器的调用。**
- `__init__()`是创建实例之后调用的第一个方法。
- `__new__()` 构造器方法。`__new__()`必须返回一个合法的实例。
- `__del__()` 解构器方法。这个函数需要到该实例对象的所有引用都被清楚之后才会执行。Python中的解构器实在实例释放前提供特殊处理的方法。通常没有被实现。因为实例很少被显式释放。也就是当引用计数边为零的时候。`__del__()`函数会被调用。
- 正因为这样。解构器只能被调用一次。

## 实例属性
- 实例仅仅拥有数据属性。严格来说就是类属性。当一个实例被释放以后，对应的属性也同时被释放回收了。
- 设置实例属性可以在实例创建以后任意时间内进行。也可以在能够访问实例代码中进行。构造器`__init__()`时设置这些属性的关键点之一。
- Python时动态类型，支持在运行时创建实例属性。这也是Python的一个优秀特性。
- 如果定义了构造器，那么`__init__()`就应该不反悔 任何对象。因为实例对象是自动在实例化调用后返回的。如果强行的使`__init__()`返回某一非空对象，那么就会有冲突。抛出错误。
- 实例仅仅有两个特殊属性。---- `__dict__` `__class__`
- `__dict__` 由一个字典组成。包含一个实例的所有属性。键是属性名。值是属性对应数据值。字典中仅有实例属性。没有类属性或者特殊属性。
- **内建类型也是类**

### 实例属性和类属性
- 类属性和实例无关。仅仅是与类相关的数据值。即使我们多次实例化中调用类。他们的值都保持不变。所以无论如何这些值都不会改变。除非你显性的改变他们的值。
- 类和实例都是名称空间。类是类属性的名字空间。实例则是实例属性的。
- 类属性可以通过类或者实例来访问。**在访问时，首先在实例中搜索，如果实例里面没有，那么接下来在类里面找，再没有就往上继承的基类找，以此类推**
- **任何对实例属性进行赋值的都会产生（创建）一个实例属性（如果不存在的话)**
- [`dir()` 和 `__dict__()` 的差异](http://stackoverflow.com/questions/14361256/whats-the-biggest-difference-between-dir-and-dict-in-python)
- 在类属性可变的情况下。可以通过实例来改变类属性。都只因为类属性可变。改变时，**并没有创建新的实例属性。而是直接改变了类属性**
- **类属性的更新会影响到所有的实例**
- 类属性 --- 静态成员。

## 绑定和方法调用
- 首先 *方法是类内部定义的函数*。这就意味着。方法是类属性而不是实例属性。
- 方法只有在其所属的类拥有实例时。才能 被调用。并且被认为是方法被绑定到那个实例了。如果没有实例那么这个方法就是未被绑定的。
- **任何一个方法定义中的第一个参数都是变量self。他表示调用此方法的实例对象**
- `self`变量用于在类实例方法中引用方法所绑定的实例。
- 调用非绑定方法有时候用在子类覆盖父类的方法时。

## 静态方法和类方法
- "一对内建函数被引入，用于将作为类定义的一部分的某一方法声明“标记（tags）“， ”强制类型转换“cast” 或者“转换（convert）“ 为这两种类型的方法之一。" -- 有待理解。
- 对于通常的方法需要一个实例作为第一个参数（self），并且对于绑定的方法调用来说。self时自动传递给这个方法的。但是对于类方法而言。需要类而不是实例作为第一个参数。他是有解释器传给方法的。 
- [新式类和经典类](http://blog.csdn.net/jb19900111/article/details/20228341)
- **装饰器表达：静态方法 @staticmethod.类方法 @classmethod**
- [有关静态方法和类方法](http://www.cnblogs.com/2gua/archive/2012/09/03/2668125.html)
 
## 组合
- 有两种方法可以在代码里面使用类。第一种是组合。就是让不同的类混合加入其他类中。来增加功能和代码的重用性。另一中方法是通过派生。

## 子类和派生
- oop的一个强大的功能是能够使用一个已经那个定义好的类扩展他或者对他进行修改。而不会影响系统中使用现存类的其他代码片段。
- OOD允许类特征在子孙类或者子类中进行继承。这些子类从基类继承他们的核心属性。
- 在一个层次的派生关系中的相关类时父类和子类的关系。但是从同一个父类派生出来的这些类是同胞关系。父类和所有的高层都被认为是祖先。

## 继承
- 继承描述了基类的属性如何“遗传”给派生类。一子类可以继承他的基类的任何属性。不管是属性还是方法。
- `class.__bases__` 查看该类的父类。与`class.__class__`有类似的作用。
- 在所说的父类时严格的相对所有基类而言那些没有父类的他们的`__bases__`属性为空。有父类的返回所有父类的元mZ。
- 当某个派生类覆盖了其父类的某个方法时，要想再次调用覆盖前的方法时需要去调用一个未绑定的基类方法。并且明确的给出子类的实例。
- **在调用未绑定的方法时。不仅有显式的调用。还可以通过`super()`来进行调用`super()`不仅能找到基类方法，而且还为我们传进self。这样只要调用子类的方法就能实现上面的功能了**
- 如果重写了`__init__`构造器方法，子类被实例化时，不会去调用基类的构造器方法。
- Python使用基类名来调用类方法。与java对应的引进了super。使用super不需要明确给出任何基类的名字。如果在一个子类里面调用了super。那么这个super会一层一层的往上，直到最顶层的父类。
- `__new__()` 的一些详细[解说](https://www.python.org/download/releases/2.2/descrintro/#__new__)

## 多重继承
- 同c++一样，python允许子类继承多个基类。这种特性就叫做**多重继承**

## 方法解释顺序（MRO）
- 在经典类里面，方法的搜索采用了**深度优先，从左至右**的算法
- 在新式类里面。方法的搜索采用了**广度优先，从左至右**的算法。
- 新式类里面有一个**__mro__**的属性可以告诉我们查找顺序是怎样的。

## 类，实例和其他对象的内建函数
> * `issubclass()` 判断一个类时另一个类的子类或者孙类 用法 `issubclass(sub, sup) ---> bool`
> * `isinstance()` 判断一个对象是否时另一个给定类的实例。 用法`isinstance(obj, obj) ----> bool`
> * `hasattr()` `getattr()` `setattr()` `delattr()` `attr 代指属性`这些函数的第二个参数必须是属性名字的字符串形式。
> * `super(class, self).***` super用来查找父类的属性。
> * `vars()`这个函数与内建函数dir（）相似，但是给定的对象都必须要有一个`__dict__` 属性。这样var才会返回一个字典。与__dict__相似的字典。但是如果没有dict属性。那么将会抛出一个`TypeError`错误。

## 用特殊方法定制类
- 方法在调用前必须被绑定。除此之外，还有两个特殊的方法可以分别作为构造器和解构器的功能。分别是`__init__` 和`__del__`
- 事实上，`__init__` 和 `__del__`只是可自定义特殊方法的集中一部分。他们中有一些域定义的默认行为。这些特殊方法时python中用来扩展类的强有力的方式。他们可以**模拟标准类型，重载操作符**  用来定制类的特殊方法详细表格见 《python核心编程》p367
- 在Python3里面，**cmp函数被代替，取而代之的是operator模块的lt之类的内建函数**
- `__iter__`仅返回`self`,这就是如何将一个对象声明为一个迭代器的方式，最后，调用next来得到迭代器中连续的值。这个迭代器的唯一亮点是他没有终点
- 在读取文件时可以使用`*.tell()` `*.seek()`来方便在文件内移动。迭代器只能next而不能回退到上一个索引位置。
- 为帮助理解这里有一段[代码](http://paste.ubuntu.com/15215136/)
- 关于`__iter__`和`iter()`迭代器的一些[细节](http://luozhaoyu.iteye.com/blog/1513198)
### 多类型定制
- 一些[例子](http://paste.ubuntu.com/15215805/)
- 在类里面命名时。使用双下划线，在程序被作为模块导入时就不能直接访问这些元素。称为私有化。

## 元类
- 元类就是类里面的类。他的实例是其他类。

## 优先级问题
```python
>>>-4 ** 2
-16
```
## 补充
> 摘自《Python学习手册》
- 类来截获运算符是通过特殊的命名方式来截获的。（也就是双下划线）也称特殊的钩子。
- 类可以覆盖多数内置类型运算。有几十种运算符重载的方法的名称，几乎可截获并实现内置类型的所有运算。不仅包括了表达式还有打印之类的。
- 类属性通常是是由class语句顶层赋值语句而产生的。
- 相反的，实例属性是通过对self参数赋值属性产生的。一般来说，实力属性都在i构造器函数里面创建。
- oop程序中最重要的两个概念是**self 参数 和 init构造器**
- oop的设计模式：**继承，组合，委托，工厂。**
- 还有一些设计理念：私有属性，多继承，边界方法。
- python的oop实现可以发概括为三个概念**继承，多态，封装**
- 面对对象中继承的关系对应"是一个"
- 面对对象中的组合对应"有一个"的关系
- 组合：也就是各种类的”“拼接组合”，每个组件都可以写成类，定义自己的行为以及关系
- 在python3里面，**无绑定方法已经删除了**。在python3里面，无绑定方法就是函数
- 因此，在python3里面可以直接调用无绑定方法，但是在2里面调用未绑定方法时，方法第一个参数必须是一个实例。
- 类是对象，因此他很容易在程序中进行传递，保存在数据结构中。
