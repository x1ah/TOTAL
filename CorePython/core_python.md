  `**.isalpha()` 检测 **中是否含有非字母字符，如果有则返回false

每一个python脚本都相当于一个 **模块**

c语言中，赋值语句为一个表达式，会返回值，在python中，赋值语句不是一个表达式，不会返回值

尽量避免用下划线来用作变量名开头，因为下划线开头有特殊含义，_xxx表示私有的

**所有类型对象的类型都是type，类就是类型，实例是类型的对象**

python的特殊类型-null对象，他只有一个值就是none
拓展的切片语法允许对不同的索引切片操作，包括步进切片，多维切片和省略切片
步进切片：`a[start:stop:num]`从start出开始切片取值，到stop结束，每次前进num个字符 

对象值的比较，对象身份的比较每个变量都指向同一个数据对象，只要任何一个引用发生变化，该对象的其他引用也会随之改变

`fool=foo2=4.3`一个值为4.3的数字对象被创建，然后这个对象的引用被赋值给`foo1`和`foo2`，结果就是`foo1`和`foo2`指向同一个对象 `4.3`和`1+3.3`是两个不同的数字对象，尽管这两个对象的值相等，当一个对象被赋值到一个变量表示创建了一个引用

测试两个变量是否指向同一个变量 `a is b` 或者`a is not b` 等价于`id(a) == id(b)` 对象身份的比较也就相当于对象`id`的比较 通过`is`或 `is not`进行比较 is 和 is not都是python关键字称为**对象身份比较操作符**

在python中，**整型对象和字符型对象是不可变对象**，所以当我们建立以下两个引用时`a = 1, b = 1`,此时`a is b`,,,但是如果`a = 1.0, b = 1.0` 这时候`a is not b`字符型对象也和整形一样

`not and or` 都是python关键字 优先级为 **`not>and>or`**

标准类型内建函数：`cmp(a, b)`比较对象a和b，如果`a>b` **返回大于零的数，反之小于零或等于零**。。。`type()`接收一个对象作为参数并返回它的**类型**，返回值是一个类型对象`str()`和`repr()`都是接收一个对象作为参数并以字符串的方式获取对象的内容并返回然后可以用另外一个内建函数`eval()`重新得到该对象

内建函数`isinstance()`，可使用help查看其具体功能，判断是否为某一类型

标准类型全称  基本内建数据对象原始类型，对类型进行分类：**1**，根据这种类型的对象能保存多少个对象，能保存单个字面对象的类型称为**原子或标量存储**，可容纳数值字符串。可容纳多个对象的类型称为**容器存储**，可存储列表元祖字典。。**2**，根据对象创建成功后其值是否可以更新分为**可变类型和不可变类型**，可变类型包括**列表，字典**。而**不可变类型包括数字，字符串，元祖**。。**3**，**访问方式，分直接存储，顺序，映射**。**顺序访问的有字符串列表元组，直接访问的有数字，映射访问有字典**

如何更新一个对象，如数字对象通过给数字对象重新赋值来更新对象，**而且这只是生成了一个新的对象并且得到了他的引用**，同理，**使用del语句可以删除对一个对象的引用**，**删除了该对象的引用就不能对其进行引用了**

python有几种整形类型比如**布尔型，标准整形，长整形**，这里长整形至于计算机的内存大小有关，可以在数字类型后面加个L来表示长整形，python中浮点型数据类似于C语言中的双精度，每个浮点型占**8个字节**
复数`a = x + yj`, `a.real`得到a的实部`a.imag`得到虚部`a.conjugate()`得到共轭复数

**工厂函数就是指这些内建函数都是类对象，当我们调用他们时，实际上是创建了一个类实例。**

python中有**5个运算内建函数**用于**数值运算**分别是 `abs()`返回对象的绝对值            `coerce(x, y)`返回仅包含一个数据类型的元组，          `divmod(x, y)`返回x除以y的商和余数       `pow(x, y)`返回x的y次幂      `round(x, y)`对浮点数x进行y位四舍五入计算。。除此之外，还有`math.fllor()`函数取得最接近原数但小于原数的整形

仅用于整形的函数：八进制转换函数`oct()`和十六进制函数`hex()`他们均接受一个**整形对象**做为参数并返回字符串对象。。ASCII转换`ord()`接受一个字符返回对应的整型值  `chr()`则相反接受一个单字节整型值返回一个字符串 `unichr()`接受unicode码值返回其对应的unicode字符 

数字类型对应模块，`decimal`模块为十进制浮点运算类。。`array`模块数值数组。。`math`模块标准c库数学运算函数。。`operator`模块数字操作符的函数实现。。`random`模块 多种伪随机数生成器

random模块 randint()随机返回二者之间的随机整形。。randrange()跟randint差不多随机返回 。  uniform（）跟randint一样只不过返回的是浮点型 random（）跟uniform类似，不过下限恒为0.0上限为1.0  。  choice（）随机返回给定序列

**求最大公约数， 大数除小数得到的余数如果为零则最大公约数为小数，如果不为零，则继续用更小的数除余数直到余数为零，最小公倍数为两数的乘积除最大公约数**

seq代表序列
字符串是由字符组成的序列，像这样的类型可以通过下表偏移量访问的称为序列
对象` [not] in` 序列 查找该对象是否在该序列里面
链接操作符 `+` 将两个序列链接起来
`序列名称[下标]` 获得下标为[]的元素
`[下标1：下标2]`获得下标1到小标2间的元素的集合
`seq*num `将序列重复num次，`ob in seq //ob  not in seq` 判断ob是否在seq里面

对于切片索引，起始切片索引可以小于零，结束切片索引任意大时也不会报错
`range(-1, -5, -1)` 对应`[-1, -2, -3, -4]`
`range(-1, -5)`对应空列表，  **可使用`none`来作为索引**
**序列本身就内含了迭代的概念**
`list(obj)` 把可迭代对象转换为列表  `str()`将对象转换为字符串 `unicode(obj)`将对象转换成unicode字符串，及使用默认编码  `tuple（iter）`将可迭代对象转换成一个元组对象    转换只是将对象进行了**浅拷贝，而不是单纯的复制**
**字符串是不可变对象，要改变一个字符串只有新建一个字符串对象**，没必要用del删除对象因为在最后程序结束时python会**自动释放**这些字符串
在对字符串进行比较时，**字符串是按照ascii值的大小来比较** 索引从零开始 在对字符串进行切片时结束索引可以超过字符串最大索引，但是不能直接使用超过最大索引来访问字符串

```python
>>> import string
>>> string.uppercase
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.lowercase
'abcdefghijklmnopqrstuvwxyz'
>>> string.Template
<class 'string.Template'>
>>> string.digits
'0123456789'
>>> string.letters
'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
>>> 
```

链接字符串的方法

```python
'%s %s' %('hello', 'wprld')
s = ' '.join(('hello', 'world'))
```


字符串格式化符号
%c转换成字符， %r优先用`repr（）`函数进行字符串转换， %s 优先用`str（）`进行字符串转换%x以十六进制输出， %o输出八进制， %u输出十进制 ， 格式化操作符辅助指令参考`core program p115 %e`科学计数法输出

还有一种字符串模板

```pyhton
>>> from string import Template
>>> s = Template('There are ${howmany} ${lang} Quotation Symbols')
>>> print s.substitute(lang='python', howmany=3)
There are 3 python Quotation Symbols
>>> 
```

***原始字符串操作符（r/R） 加在第一个引号前**
unicode字符串操作符（u/U) unicode字符串操作符必须出现在原始字符串操作符前面

```python
>>> for i, j in enume           te(s):
	print i, j

	
0 f
1 o
2 o
3 b
4 a
5 r
```

`zip(it0, it1, it2....)` 返回一个列表，其第一个元素是各个参数的第一个元素组成，以此类推

`help（str）`

当修改或者对字符串做一些修改内容的操作时也就意味着python自动的分配给我们一个**新串**，为新的字符串分配了空间
对字符串不能直接进行修改，为实现需求，我们需要用现有字符串的子串来构建一个新串，然后把这个新串赋值给原来的变量
比如`s='helloworld'`要使w变大写应该`s='%sW%s' %(s[0:2], [3:1])`

ascii 美国标准信息交换码BMP基本多文种平面BOM字节顺序标记UTFunicode或者UCS的转换格式  `utf-8`位UTF转换格式  `UTF-16` 16位utf转换格式 详见core program p127

unicode编码 现有的分为ascii编码和unicode编码，ascii用的是单字节来表示字符，而unicode用多个字节表示字符，unicode使用的范围及其广泛unicode可表示超过90000个字符 ascii只能表示223个 unicode的使用 在字符串前面加上u 比如

```python
a = u'你好'
print a
你好
```

python 中open函数有w 和r 。w为以读的模式打开文件，r是以写的模式打开文件

字符串是引号之间的字符，不包含引号本身
比如用cmp内建函数对数据类型进行比较，在数据类型中，**数字是最小的，或者是列表，在列表里面，长度大的列表则大**

```
help（list）
reversed（）
```

用`dir（）`来访问某类型的方法和属性

那些可以改变对象值的**可变对象的方法是没有返回值的**
比如`list.sort()  list.reverse()`这样的方法是没有返回值的，所以当你用`a = list.reverse()`时a就是`none`了，因为它没有返回值

**但是对于字符串就有返回值，所以字符串的这些方法就可以用作表达式**

堆栈：堆栈是一个后进先出的数据结构，其工作方式就死昂自助餐厅里面用于放盘子的弹簧支架，把盘子想象成对象，第一个离开堆栈的是你最后放上的那个，在栈上“push”元素是个常用术语，意思是把一个对象添加到堆栈中。反之。要删除一个元素，你可以把它“`pop`”出堆栈。

元组是**不可变类型**，要想更新元组就应该新建一个新的元组，同样，删除元组的元素可以通过del来实现

虽然元组对象本身是不可变的，但是这不意味着元组包含的可变对象也不可变 比如
`a = (['asd', 'ghj'], 123, 345]`
该元组对象本身是不可变的，但是他包含了一个可变的元素，所以该元素是可变的

**所有的多对象的、逗号分隔的、没有明确的用符号定义的这些集合默认的类型都是元组，所有函数返回的多对象的也都是元组类型**
有圆括号包裹的一个单一元素的首先被称为**分组操作**而不是作为分组的分界符，**要使他变成单个元素的元组**，只需要在最后面添加一个逗号来表明这是一个元组而不是在做分组操作

字典是python中唯一的映射类型，映射类型里面的哈希值（键key）和指向的对象（值value）是一对多的关系字典对象是可变的，能存储任意多个对象，包括其他容器类型，字典类型和序列类型容器类（列表，元组）的区别是存储和访问数据的方式不同，序列类型只可以数字类型的键（从序列开始起按数值顺序索引），映射类型可以用其他类型对象做键，映射类型的数据是无序的，

**映射类型可以直接用键“映射”到值，这就是为什么叫映射类型了，映射类型通常叫哈希表，硬尾字典类型是哈希类型的**

哈希表中每一条数据都叫做一个值，而根据与她相关的一个叫做 键的数据项进行存储的 哈希表的算法是获取键，对剑执行一个叫做哈希函数的操作

```python
>>> dict(([1, 2], [2, 3]))
{1: 2, 2: 3}建立一个字典的特殊方法
>>> a = {}.fromkeys(('a', 's'), 3)
>>> a
{'a': 3, 's': 3}
```

删除整个字典 可用dict.clear()但是删除整个字典很不常见，不推荐使用也可用pop（*）来删除某个字典元素

字典也可以进行大小的比较，其比较方式与序列类型相似但是不尽相同，比起复杂

对于字典来说，**键是一个参数（argument）而不是想序列类型里面的索引（index）**，

字典大小的比较，首先对字典的长度进行比较，接着比较字典的键，如果键相等，那么就比较键的值，比较规则与序列类型的相似可用cmp（）内建函数进行比较，说明字典中键的个数越多，这个字典就越大，键比较的顺序和key返回键的顺序一样，这里，相同的键会映射到哈希表的同一位置，这就不会造成两个字典有相同键的时候而比较不同键

所以，如果两个字典具有相同的键，相同的值，相同的长度，那么这两个字典就是**完全匹配**的

**用工厂函数dict（）创建一个字典对象，如果不提供任何参数，那么创建一个空字典，让对象是一个容器类性对象时，如果参数是可迭代的，即一个序列，或者是一个迭代器，或者是一个支持迭代的对象，那么每个可迭代对象必须成对出现，在每个值中，第一个元素是对应的键，第二个元素是对应的值 详见core p170**

复制一个字典 **.copy（）

**hash(*)返回*的哈希值，只有这个对象是可哈希的才能作为字典的键**

字典对象里面，不允许一个键对应多个值，键必须是可哈希的，当一个键对应多个值时，python不会因为间存在而产生冲突，不会检查间的冲突是因为这样做的话，每个键-值对复制的时候都会做检查，这将会占用一定量的内存，他只会不断更新键的值，所有不可变的类型都是可哈希的，对于数字，只要数字的值相等，不管是整形还是浮点型，那么他们哈希值都相同，所以是相同的键，有极少数的可变对象也是可哈希的可以作为键

集合对象是一组无序的可哈希值，所以**集合元素可以作为字典的键**，集合可分为两种类型，**可变类型和不可变类型**，可变类型没有哈希值，所以不能当做字典的键，然而不可变集合具有哈希值，所以能作为字典的键以及其他集合的元素，可变集合你可以增加或者删除元素，不可变集合就不能。

集合类型 
集合操作符  **&交集  | 合集  - 相对补集 ^ 对称差分  <  真包含  <= 包含**同理有大于
用集合的工厂函数 `set（）` 和 `frozenset（）` 可以创建集合 frozenset为不可变集合
通过`in` 和 `not in` 访问集合元素 
有许多内建的方法对集合进行修改 `dir（set)`
只有可变集合才能被修改，所以frozenset集合即不可变集合是不能被修改的
同样可以用del 淡出集合本身

> | 联合操作符有一个等价的 方法 叫 union（）  s1 | s2
> & 交集有一个等价的方法 叫 intersection（） 
> - 差集也有一个等价的方法 叫 difference（）
> ^ 对称差分 指的是两个集合中 分别只有自己的集合里面有而另外一个集合没有的元素

上述操作符 **当两边的类型一样时 结果与他们的类型一样，当两者的类型不一样时 结果的类型与左边的类型一致**

集合类型操作符 

> |=  将后面的添加到前面的集合里面 此方法与 update类似
> &= 取两集合的交集 此方法与 intersection——update（）类似
> -= 取差集，去除前面集合里面所包含的后面集合的元素并返回 此方法与difference_update（）类似
> ^= 对称差分操作 对两集合进行对称差分操作 返回后的集合只包含原集合两个之中不同的元素

集合类型工厂函数 `set` 和`frozen（）`分别用来产生一个可变集合和不可变集合 必须提供一个参数 而且这个参数必须是**可迭代的** 一个序列或者迭代器 后者一个支持迭代的对象 例如一个字典或者文件 


第八章：条件和循环；
如果if后面的符合条件的代码块只有一行代码，这个代码块叫复合语句；如果符合语句只有一行，那么这个符合语句可以跟前面的语句写在一行，但是这样虽然可能方便，但是不利于阅读，所以不推荐。

**避免悬挂else**，臭名昭著的错误，python的缩进使用强制使代码对齐，

if后面至多只能有一个else，但是能有任意多个elif

**有些情况下elif是能用字典来代替的**

三元操作符，条件表达式。
比如要取两者中的更小值，
`smaller = x if x < y else y`

for 循环会返回一个可迭代对象中所有元素，并在所有条目都处理过后结束循环

**直接迭代序列和通过索引迭代，直接迭代要比通过索引迭代快，还有通过项和索引迭代，即enumerate（）。称为两全其美的方法**

`range（start， end， step）`
从start开始，包括start，到end结束，每次递增step，返回一个列表。如果没有给定step，那么默认就是1。start默认为0.但是不能只传递end参数和step两个参数，这样就会默认的将end和step看成start和end。所以step必须与start共存。

xrange() xrange不返回一个列表，，而且只被用在for循环里面，在for循环外面并没有意义，**xrange生成的不是一个列表也不是生成一个迭代器，而是生成一个可迭代对象。这样的话性能就要远高出range了**

**与序列相关的内建函数，`sorted（）`和`zip（）`返回的是一个列表（序列）而`enumerate（）`和`reversed（）`返回的是迭代器（类似序列）。**

**break语句可以用在while和for语句中。不能用在单纯地if语句中。**

continue语句，continue语句为立即启动下一次迭代，当遇到continue时，程序会终止当前循环，并且忽略剩余的语句，然后回到循环的顶端。开始下一次迭代前，如果是条件迭代，我们将验证条件表达式，如果是迭代循环，我们开始下一次迭代前将验证是否还有元素可迭代

pass语句。python在某些地方必须要求有代码，不写代码就会报语法错误，这是就需要pass语句，

else也可与while语句搭配使用。

迭代器：他是一种数据结构，他为序列对象提供了一个类序列的接口。迭代器用起来非常灵巧，可以迭代不是序列但是表现出序列行为的对象。
提供了可扩展的迭代器接口。
对列表迭代带来了性能上的提升。
在字典迭代中性能提升。
创建真正的迭代接口，而不是原来的随机对象访问。
与所有已经存在的用户定义的类以及扩展的模拟序列和映射的对象向后兼容。
迭代非序列集合时，可以创建更简洁可读的代码。、

根本上说，迭代器就是有一个`next（）`方法的对象。而不是用索引来计数。

**迭代器不能复制。要再次迭代同个对象时，只能去创建一个新的迭代器对象。**

在迭代字典的键时 ，绝对不能改变字典。因为更新会立即反映到所迭代的条目上。

`expr for iter_var in iterable`
首先迭代iterable里面的所有条目，前面的expr应用于序列的每个成员。，最后结果值是该表达式产生的列表。

`map（）`对所有列表成员应用一个操作。`filter（）`基于一个条件表达式过滤列表成员。
`map(lambda x: x ** 2, range(9))`
等价于
`x**2 for x in range(9)`

`filter(lambda x: x % 2, seq)`
`> x for x in seq if X％2`

文件只是连续的字节序列，数据传输经常会用到字节流，无论字节流是由单个字节还是大块数据组成。
文件也是对象，万物皆对象。

内建函数`open（）`提供了初始化输入/输出（I/O)操作的通用接口。`open（）`函数成功打开文件后会返回一个文件对象。否则引发一个错误。

通常文件以 'r', 'w', 'a'等模式来打开。分别代表读 写 追加。还有个‘u’模式，指通用换行符。使用u r 模式打开文件必须是已经存在的文件。使用w模式打开文件若文件存在则先清空，然后重新创建。

如果文件不存在，那么将会自动创建。
‘+’代表可读可写。
‘b’代表以二进制模式访问


UNS（universal newline support）通用换行符支持。、
当使用u模式打开文件时。所有的行分隔符（或者行结束符。无论是什么他原来）通过python的输入法返回时都会被换成换行符（\n)

文件方法包括输入输出，文件内移动和杂项操作

`readline（）`方法会读取所有的行。然后整行包括航结束符一起作为字符串返回。
`readlines（）`将返回一个行列表。

**print 语句会自动在要输出的字符串后面加上换行符**

`sys.argv` 属性提供了对命令行参数的访问。命令行参数是调用某个程序时除程序名以外的其他参数。
命令行参数就是`argv`（参数向量）

永久存储模块： 大部分永久存储模块是用来存储字符串数据的，但是也有方法来归档python对象。

数据的扁平化、数据的序列化、数据的顺序化、python提供了许多可以实现最小化永久性存储的模块，其中的一组就是（marshal和pickle）可以用来转换并存储python对象，该过程将比基本类型复杂的对象转换为一个二进制数据集合。这样就可以把数据集合保存起来或者通过网络发送。然后再重新把数据集合恢复成原来的对象格式。这个过程就是前面讲的那些概念。

```
绝对路径：某个文件在计算机里面的完整路径。
相对路径：某个文件相对路径就是比如a在c:/python/core另外一个文件c:/python/core/stuff那么b的相对路径就是stuff，也就是相对的路径。不是计算机的完整路径，相当于量路径相对意义上的相减
```

`round（number[, ndigits])`四舍五入
`set([])`集合，里面的元素不能重复

`format（）`函数也就是2.6以后的格式化字符，能够代替%，具体用法参考百度
