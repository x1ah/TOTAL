# 函数和函数式编程
- `python` 中的函数支持多种调用方式和参数类型并实现一些函数式的编程接口。
- 函数和过程： 两者都是可以被调用的实体。但是传统意义上的函数或者“黑盒”可能不带任何输入参数，经过一定的处理，最后向调用者传回返回值。其中一些函数则是布尔类型的，返回true或者false，更确切的说，一个非零或者零值，**而过程**是简单，特殊，没有返回值的函数。
- 传统意义上的函数。就是有返回值，当调用者调用这个函数时函数给调用者返回该返回值，而过程时没有返回值的函数，只是定义了一个函数但是没有返回值，一个简单的过程。
- 在python里面。python的函数可以返回一个值或者一个对象。容器对象看起来像是返回了多个值，其实还是返回了一个容器对象，好比返回了很多个，没有用括号括起来，事实上返回了一个元组对象。元组语法上不一定要带括号。
- 如果python函数返回多个对象，python会自动把他们聚集起来返回一个元组。
- 关键字参数。调用一个函数可以使用标准调用和关键字参数调用。
```
def foo(x):
    foo_suite
标准调用：foo(x)
关键字调用：foo(x=10)
```

- 默认参数就是在定义函数时就已经声明了默认值的参数。
- python里面也是不允许在函数未声明之前调用或者引用。
## 函数属性。
- 函数属性是python另外一个使用了句点属性标识并拥有名称空间的领域。
- 在两个模块里面使用相同名字的变量也是可以的。这也是安全的。在导入某个模块之后，模块里面的变量在程序里面依然可以用。因为句点属性标识对于两个模块意味着不同的命名空间。
 函数声明与函数定义：
    声明：包括提供对函数名，参数名字但不必给出任何代码，具体的代码通常属于函数定义的范畴。
    定义：
**在python中，函数的子句由声明的标题行以及定义体组成**

- 在函数体内创建另外一个函数（对象）是完全合法的。这种函数叫**内部/内嵌函数**
- 内部函数只有在函数体内才能对其引用调用，在函数体外，任何地方都不能对其进行调用。
## **函数装饰器**
- 装饰器的主要动机源自python 面向对象编程。装饰器是在函数调用之上的修饰。这些修饰仅仅当声明一个函数或者方法的时候，才会应用的额外调用。装饰器的语法以`@`开头，接着是装饰器函数的名字和可选的参数。
```python
@f
@g
def foo(): pass

等价于
foo = g(f(foo))
```

```python
@f
def foo(): pass
等价于
foo = f(foo)
```
- 有参数和无参数的装饰器。**带参数的装饰器mZ要自己返回以函数作为参数的装饰器。**
- 装饰器实际上就是函数。他们接受函数对象。

## 传递参数
- 函数可以被引用。也可以当成参数被传入函数。函数是可调用的。
- **所有的对象都是通过引用来传递的**函数也不例外，当对一个变量赋值时，实际上是将相同对象的引用赋值给这个变量。如果对象时函数的时候，这个对象的所有别名都是可调用的。
- 函数也可以当做字典列表等对象的元素 
- 位置参数：位置参数必须以在被调用函数中定义的准确顺序来传递。另外，有任何默认参数的话，传入函数的参数的精确数目必须和声明的数字一致。
- 默认参数：如果默认参数在函数调用时没有为参数提供值则使用预先定义的默认值, 在Python里面。**默认值声明必须在所有位置参数后面**
- 关键字参数。可以不按声明函数的时候参数顺序进行调用。比如：
```
def foo(hello, world):
    print hello, world

print foo(world='world', hello='hello')
```

这样参数没有按照顺序来进行传递，这就叫关键字参数`
#　python内存管理
- 变量无需实现说明
- 变量无需指定类型
- 程序员不用关心内存管理
- 变量名会被回收
- del语句能够直接释放资源

## 可变长度的参数
### 非关键字可变长参数（元组）
- 当函数被调用时，所有的形参都将赋值给在函数中相对应的局部变量
- **可变长度的参数必须在所有的位置参数和默认参数后面。**
```用法：
def ([formal_args, ] *vargs_tuple ):
    ***
```
- 星号之后的形参将作为元组传递给函数。
### 关键字变量参数
```用法：
def **([formal_args, ] *vargs_tuple, **vargsd):
    ***
```
- 一个星号后面带元组，两个星号后面带字典，字典参数。参数顺序依次是位置参数，默认参数，非关键字可变长参数，关键字变量参数
## 函数式编程
- python不是也不大可能成为一种函数式编程语言。但是他支持许多由价值的函数式编程语言构建。python提供的以四种内建函数和lambda表达式的形式出现。
- python允许lambda表达式创建匿名函数，lambda表达式的定义体必须和声明放在同一行。
- lambda表达式返回可调用的函数对象。
- **python中单行函数可以和标题写在同一行**
`lambda : = True`因为这个lambda表达式创建的函数没有任何引用来保存他，所以计数又被清零，然后被垃圾回收掉。
`true = lambda : True` 这样就增加了一个引用，保存了true。
- lambda表达式运行起来就像一个函数，当被调用时，创建一个框架对象。
- **函数式编程的内建函数**： `filter()`过滤函数。讲传入的序列进行过滤。返回值为true的再输出，返回一个返回值为true的列表。`map()`跟filter类似，但是，map是将返回一个含有一个序列中所有的返回值的列表。`reduce（）`reduce就是每次前进一个位置，进行‘**迭代**’，然后返回一个值。
## 变量作用域
- 作用域即其在程序中的可应用范围，变量可以是局部域或者全局域。
- 搜索标识符（也称变量），当搜索一个标识符时，先从局部作用域开始搜索。然后再是全局作用域。如果局部和全局都没有，那么就会抛出NameError错误。
- 在函数里面声明`global`就相当于直接对全局变量进行引用。
## 闭包
- 由于python的静态嵌套域，定义内部函数就变得很有用处。
- **闭包**在内部函数里面对在外部作用域的变量进行引用，那么内部函数就被认为时闭包（closure）。
- 定义在外部函数内的但由内部函数引用或者使用的变量被称为自由变量。
## 作用域和lambda
- lambda表达式：在两种形似下，分别有两种作用，作用域不同。
```
foo = lambda x, y: x + y
 foo = lambda : x + y
```
 - 第二种lambda表达式不接受参数，第一种必须接受xy参数。第二种lambda表达式的作用域也可以访问函数内部。
 - **函数和lambda都可以访问全局变量，但是两者都不能访问彼此的局部作用域**
## 生成器
- 生成器的另外一个方面甚至更加强力---**协同程序**的概念: 协同程序时可以运行的独立函数的调用，可以暂停或者挂起，并且从程序离开的地方继续或者重新开始，在有调用者和协同程序也有通信。
- **从语法上讲，生成器就是带`yield`语句的函数。**
